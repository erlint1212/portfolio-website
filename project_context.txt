Project Directory Structure:
============================
./
    README.md
    flake.nix
    flake.lock
    go.mod
    '
    go.sum
    .gitignore
    internal/
        views/
            hello_templ.go
            hello.templ
        server/
            server.go
            json.go.bak
            routes.go.bak
            handlers.go.bak
    cmd/
        web/
            main.go
        api/
            main.go


File Contents:
==============

--- START OF FILE: ./flake.nix ---
{
  description = "Backend Archmage Portfolio Environment";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-25.11";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            go
            templ
            docker
            kubectl
            rabbitmq-server
            
            # Useful tools for debugging
            curl 
            jq
          ];

          shellHook = ''
            echo "Environment: Go + Htmx +Templ + K8s"
            echo "------------------------------------------------"
            go version
            templ --version
          '';
        };
      }
    );
}

--- END OF FILE: ./flake.nix ---

--- START OF FILE: ./.gitignore ---
context_builder.py

--- END OF FILE: ./.gitignore ---

--- START OF FILE: ./internal/views/hello_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Hello(name string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>Hello ")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/views/hello.templ`, Line: 4, Col: 20}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "!</h1>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/hello_templ.go ---

--- START OF FILE: ./internal/views/hello.templ ---
package views

templ Hello(name string) {
    <h1>Hello { name }!</h1>
}

--- END OF FILE: ./internal/views/hello.templ ---

--- START OF FILE: ./internal/server/server.go ---
package server

import (
	"net/http"
	"github.com/a-h/templ"
	"github.com/erlint1212/portfolio/internal/views"
)

type Server struct {
	port int
}

func HandleCreator() http.Handler {
	mux := http.NewServeMux()

	component := views.Hello("Apprentice")
	
	mux.Handle("/", templ.Handler(component))

	return mux
}

func NewServer(handler http.Handler) *http.Server {
	const port = "8000"
	
	mux := handler
	
	srv := &http.Server{
		Addr:		":" + port,
		Handler:	mux,
	}

	return srv

}

--- END OF FILE: ./internal/server/server.go ---

--- START OF FILE: ./cmd/web/main.go ---
package main

import (
	"github.com/erlint1212/portfolio/internal/server"
	"log"
)

func main() {
	mux := server.HandleCreator()
	srv := server.NewServer(mux)

	log.Printf("Serving on: http://localhost%s/\n", srv.Addr)
	log.Fatal(srv.ListenAndServe())
}

--- END OF FILE: ./cmd/web/main.go ---

--- START OF FILE: ./cmd/api/main.go ---

--- END OF FILE: ./cmd/api/main.go ---
