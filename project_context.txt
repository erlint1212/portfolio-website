Project Directory Structure:
============================
./
    ideas.md
    README.md
    flake.nix
    TODO.md
    flake.lock
    challenge.md
    go.mod
    '
    tailwind.config.js
    go.sum
    Dockerfile
    .gitignore
    internal/
        routing/
            routing.go
            structs.go
        messaging/
            subscribe.go
            publish.go
            client.go
        views/
            layout.templ
            hello_templ.go
            hello.templ
            debug_templ.go
            projects_templ.go
            debug.templ
            projects.templ
            home_templ.go
            home.templ
            layout_templ.go
            components/
        server/
            server.go
    cmd/
        web/
            main.go
    kubernetes/
        portfolio-rabbitmq-deployment.yaml
        portfolio-rabbitmq-configmap.yaml
        portfolio-rabbitmq-service.yaml
        portfolio-deployment.yaml
        portfolio-configmap.yaml
        portfolio-service.yaml


File Contents:
==============

--- START OF FILE: ./flake.nix ---
{
  description = "Backend Archmage Portfolio Environment";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-25.11";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            go
            templ
            docker
            kubectl
            minikube
            rabbitmq-server
            tailwindcss

            python313Packages.pathspec
            
            # Useful tools for debugging
            curl 
            jq
          ];

          shellHook = ''
            echo "Enter the Minikube Docker Environment"
            eval $(minikube docker-env)
            echo "Environment: GOTH: Go + Tailwind + Htmx + Templ + K8s"
            echo "------------------------------------------------"
            go version
            templ --version
            alias tgr='templ generate && go run cmd/web/main.go'
            alias k='kubectl'
            alias kgp='kubectl get pods'
            echo "Commands:"
            echo "Tailwind CSS: tailwindcss -i ./internal/assets/css/input.css -o ./assets/css/output.css"
            echo "RabbitMQ: kubectl port-forward service/portfolio-rabbitmq-service 5672:5672"
            echo "Website: kubectl port-forward service/portfolio-service 8000:80"
          '';
        };
      }
    );
}

--- END OF FILE: ./flake.nix ---

--- START OF FILE: ./go.mod ---
module github.com/erlint1212/portfolio

go 1.25.5

require github.com/a-h/templ v0.3.960

require github.com/rabbitmq/amqp091-go v1.10.0 // indirect

--- END OF FILE: ./go.mod ---

--- START OF FILE: ./.gitignore ---
# Go Artifacts
# Binaries
/bin/
/dist/
main
portfolio
*.exe
*.test

# Vendor 
vendor/
assets/

# Nix & Direnv 
.direnv/
result
result-*

# OS & Editor Clutter 
.DS_Store
.idea/
.vscode/
*.swp
*.swo

# Project Specific Junk 
*.bak
project_context.txt
context_builder.py

--- END OF FILE: ./.gitignore ---

--- START OF FILE: ./internal/routing/routing.go ---
package routing

const (
	GameLogSlug = "game_logs"
)

const (
	ExchangePortfolioDirect = "portfolio_direct"
	ExchangePortfolioTopic  = "portfolio_topic"
)

type SimpleQueueType int

const (
	Transient SimpleQueueType = iota
	Durable
)

type AckType int

const (
	Ack AckType = iota
	NackRequeue
	NackDiscard
)


--- END OF FILE: ./internal/routing/routing.go ---

--- START OF FILE: ./internal/routing/structs.go ---
package routing

import "time"

type GameLog struct {
	CurrentTime time.Time
	Message     string
	// Username    string
}


--- END OF FILE: ./internal/routing/structs.go ---

--- START OF FILE: ./internal/messaging/subscribe.go ---
package messaging

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"log"

	"github.com/erlint1212/portfolio/internal/routing"
	amqp "github.com/rabbitmq/amqp091-go"
)

func WriteLog(gl routing.GameLog) error {
	log.Printf("[GameLog] %s: %s", gl.CurrentTime.Format("15:04:05"), gl.Message)
	return nil
}

func UnmarshalGob[T any](data []byte) (T, error) {
	buffer := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buffer)
	var target T
	err := decoder.Decode(&target)
	return target, err
}

func HandlerWriteLog() func(gl routing.GameLog) routing.AckType {
	return func(gl routing.GameLog) routing.AckType {
		err := WriteLog(gl)
		if err != nil {
			log.Printf("[ERROR] Couldn't write to log: %v\n", err)
			return routing.NackDiscard
		}
		return routing.Ack
	}
}

func Subscribe[T any](
	conn *amqp.Connection,
	exchange,
	queueName,
	key string,
	queueType routing.SimpleQueueType,
	handler func(T) routing.AckType,
	unmarshaller func([]byte) (T, error),
) error {
	ch, queue, err := DeclareAndBind(conn, exchange, queueName, key, queueType)
	if err != nil {
		return fmt.Errorf("could not declare and bind queue: %v", err)
	}

	err = ch.Qos(10, 0, false)
	if err != nil {
		return fmt.Errorf("could not set qos: %v", err)
	}

	msgs, err := ch.Consume(
		queue.Name, "", false, false, false, false, nil,
	)
	if err != nil {
		return fmt.Errorf("could not consume messages: %v", err)
	}

	go func() {
		defer ch.Close()
		for msg := range msgs {
			target, err := unmarshaller(msg.Body)
			if err != nil {
				fmt.Printf("could not unmarshal message: %v\n", err)
				msg.Ack(false) 
				continue
			}
			acktype := handler(target)
			switch acktype {
			case routing.Ack:
				msg.Ack(false)
			case routing.NackRequeue:
				msg.Nack(false, true)
			case routing.NackDiscard:
				msg.Nack(false, false)
			}
		}
	}()
	return nil
}

--- END OF FILE: ./internal/messaging/subscribe.go ---

--- START OF FILE: ./internal/messaging/publish.go ---
package messaging

import (
	"bytes"
	"context"
	"encoding/gob"
	"fmt"
	"log"
	"sync"

	"github.com/erlint1212/portfolio/internal/routing"
	amqp "github.com/rabbitmq/amqp091-go"
)

type Publisher struct {
	channel *amqp.Channel
	mu      sync.Mutex 
}

func NewPublisher(conn *amqp.Connection) (*Publisher, error) {
	ch, err := conn.Channel()
	if err != nil {
		return nil, err
	}
	return &Publisher{channel: ch}, nil
}

func (p *Publisher) Close() error {
	return p.channel.Close()
}

func PublishGob[T any](ctx context.Context,ch *amqp.Channel, exchange, key string, val T) error {
	var buffer bytes.Buffer
	encoder := gob.NewEncoder(&buffer)
	err := encoder.Encode(val)
	if err != nil {
		return err
	}

	msg := amqp.Publishing{
		ContentType: "application/gob",
		Body:        buffer.Bytes(),
	}

	return ch.PublishWithContext(ctx, exchange, key, false, false, msg)
}

func (p *Publisher) PublishGameLog(ctx context.Context, gl routing.GameLog) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	key := fmt.Sprintf("%s.guest", routing.GameLogSlug)

	err := PublishGob(
		ctx,
		p.channel,
		routing.ExchangePortfolioTopic,
		key,
		gl,
	)

	if err != nil {
		log.Printf("[ERROR] Error during publishing GameLog: %v", err)
		return err
	}
	return nil
}

--- END OF FILE: ./internal/messaging/publish.go ---

--- START OF FILE: ./internal/messaging/client.go ---
package messaging

import (
	amqp "github.com/rabbitmq/amqp091-go"
	"github.com/erlint1212/portfolio/internal/routing"
	"fmt"
)

type Client struct {
	Conn *amqp.Connection
}

func NewClient(url string) (*Client, error) {
	connection, err := amqp.Dial(url)
	if err != nil {
		return nil, err
	}

	client := Client{
		Conn: connection,
	}

	return &client, nil
}

func (c *Client) Close() error {
	return c.Conn.Close()
}

func DeclareAndBind(
	conn *amqp.Connection,
	exchange,
	queueName,
	key string,
	queueType routing.SimpleQueueType, // an enum to represent "durable" or "transient"
) (*amqp.Channel, amqp.Queue, error) {
	channel, err := conn.Channel()
	if err != nil {
		return nil, amqp.Queue{}, err
	}

	transient := false
	durable := false
	switch queueType {
	case routing.Transient:
		transient = true
	case routing.Durable:
		durable = true
	default:
		return nil, amqp.Queue{}, fmt.Errorf("queueType not recognized: %v", queueType)
	}

	args := amqp.Table{"x-dead-letter-exchange": "portfolio_dlx"}

	queue, err := channel.QueueDeclare(queueName, durable, transient, transient, false, args)
	if err != nil {
		return nil, amqp.Queue{}, err
	}
	fmt.Printf("Log: Name of queue \"%v\"\n", queue.Name)

	err = channel.QueueBind(queueName, key, exchange, false, nil)
	if err != nil {
		return nil, amqp.Queue{}, err
	}

	return channel, queue, err
}


--- END OF FILE: ./internal/messaging/client.go ---

--- START OF FILE: ./internal/views/layout.templ ---
package views

templ Base(title string, content templ.Component) {
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <title>{ title }</title>
        <script src="https://unpkg.com/htmx.org@1.9.10"></script>
        <link href="assets/css/output.css" rel="stylesheet">
    </head>
    <body class="bg-gray-100 text-gray-900 font-sans">
        <main class="max-w-4xl mx-auto p-4">
            @content
        </main>
    </body>
    </html>
}

--- END OF FILE: ./internal/views/layout.templ ---

--- START OF FILE: ./internal/views/hello_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Hello(name string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>Hello ")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/views/hello.templ`, Line: 4, Col: 20}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "!</h1>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/hello_templ.go ---

--- START OF FILE: ./internal/views/hello.templ ---
package views

templ Hello(name string) {
    <h1>Hello { name }!</h1>
}

--- END OF FILE: ./internal/views/hello.templ ---

--- START OF FILE: ./internal/views/debug_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func HtmxIndicator() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div id=\"htmx-check\" style=\"position: fixed; bottom: 10px; right: 10px; background: #333; color: #fff; padding: 5px 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 9999; opacity: 0.8;\">HTMX: <span id=\"htmx-version\">Loading...</span></div><script>\n        document.addEventListener('DOMContentLoaded', () => {\n            if (typeof htmx !== 'undefined') {\n                document.getElementById('htmx-version').innerText = htmx.version;\n                document.getElementById('htmx-check').style.borderLeft = \"4px solid #4CAF50\";\n            } else {\n                document.getElementById('htmx-check').innerText = \"HTMX Offline\";\n                document.getElementById('htmx-check').style.background = \"#ff0000\";\n            }\n        });\n    </script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/debug_templ.go ---

--- START OF FILE: ./internal/views/projects_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func ProjectList() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div id=\"game-container\"><ul><li><button hx-get=\"/games/rpg\" hx-target=\"#game-container\" hx-swap=\"innerHTML\" class=\"button\">Masked Platformer Game</button></li><li>Portfolio</li><li>Chat App</li></ul></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func GameView(game_path string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var2 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var2 == nil {
			templ_7745c5c3_Var2 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<div class=\"game-container\"><iframe src=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(game_path)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/views/projects.templ`, Line: 19, Col: 31}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "\" width=\"800\" height=\"600\" frameborder=\"0\"></iframe><br><button hx-get=\"/projects\" hx-target=\"#game-container\" hx-swap=\"outerHTML\">Back to List</button></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/projects_templ.go ---

--- START OF FILE: ./internal/views/debug.templ ---
package views

templ HtmxIndicator() {
    <div 
        id="htmx-check"
        style="position: fixed; bottom: 10px; right: 10px; background: #333; color: #fff; padding: 5px 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 9999; opacity: 0.8;"
    >
        HTMX: <span id="htmx-version">Loading...</span>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof htmx !== 'undefined') {
                document.getElementById('htmx-version').innerText = htmx.version;
                document.getElementById('htmx-check').style.borderLeft = "4px solid #4CAF50";
            } else {
                document.getElementById('htmx-check').innerText = "HTMX Offline";
                document.getElementById('htmx-check').style.background = "#ff0000";
            }
        });
    </script>
}

--- END OF FILE: ./internal/views/debug.templ ---

--- START OF FILE: ./internal/views/projects.templ ---
package views

templ ProjectList() {
    <div id="game-container">
        <ul>
            <li>
                <button hx-get="/games/rpg" hx-target="#game-container" hx-swap="innerHTML" class="button">
                    Masked Platformer Game
                </button>
            </li>
            <li>Portfolio</li>
            <li>Chat App</li>
        </ul>
    </div>
}

templ GameView(game_path string) {
    <div class="game-container">
        <iframe src={ game_path } width="800" height="600" frameborder="0"></iframe>
        <br/>
        <button hx-get="/projects" hx-target="#game-container" hx-swap="outerHTML">Back to List</button>
    </div>
}

--- END OF FILE: ./internal/views/projects.templ ---

--- START OF FILE: ./internal/views/home_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Home(title string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = Base("home", homeContent()).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func homeContent() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var2 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var2 == nil {
			templ_7745c5c3_Var2 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = HtmxIndicator().Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>Welcome to my portfoilio page!</h1>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = ProjectList().Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/home_templ.go ---

--- START OF FILE: ./internal/views/home.templ ---
package views

templ Home(title string) {
    @Base("home", homeContent())
}

templ homeContent() {
    @HtmxIndicator()
    <h1>Welcome to my portfoilio page!</h1>
    @ProjectList()
}

--- END OF FILE: ./internal/views/home.templ ---

--- START OF FILE: ./internal/views/layout_templ.go ---
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Base(title string, content templ.Component) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<!doctype html><html lang=\"en\"><head><title>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(title)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/views/layout.templ`, Line: 7, Col: 22}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "</title><script src=\"https://unpkg.com/htmx.org@1.9.10\"></script><link href=\"assets/css/output.css\" rel=\"stylesheet\"></head><body class=\"bg-gray-100 text-gray-900 font-sans\"><main class=\"max-w-4xl mx-auto p-4\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = content.Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</main></body></html>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate

--- END OF FILE: ./internal/views/layout_templ.go ---

--- START OF FILE: ./internal/server/server.go ---
package server

import (
	"log"
	"net/http"
	"time"

	"github.com/a-h/templ"
	"github.com/erlint1212/portfolio/internal/messaging"
	"github.com/erlint1212/portfolio/internal/routing"
	"github.com/erlint1212/portfolio/internal/views"
)

type Server struct {
	Addr      string
	Client    *messaging.Client
	Publisher *messaging.Publisher 
}

func addGodotHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cross-Origin-Opener-Policy", "same-origin")
		w.Header().Set("Cross-Origin-Embedder-Policy", "require-corp")
		next.ServeHTTP(w, r)
	})
}

func (s *Server) handlerUserStartGame(w http.ResponseWriter, r *http.Request) {
	if s.Publisher != nil {
		msg := "User started RPG Game"
		gl := routing.GameLog{
			CurrentTime: time.Now(),
			Message:     msg,
		}
		err := s.Publisher.PublishGameLog(r.Context(), gl)
		if err != nil {
			log.Printf("Failed to publish event: %v", err)
		}
	} else {
		log.Println("[WARNING] Publisher is nil, skipping log.")
	}

	templ.Handler(views.GameView("/assets/games/rpg/index.html")).ServeHTTP(w, r)
}

func (s *Server) RegisterRoutes() http.Handler {
	mux := http.NewServeMux()

	home_component := views.Home("Apprentice")
	projects_component := views.ProjectList()

	mux.Handle("/", templ.Handler(home_component))
	mux.Handle("/projects", templ.Handler(projects_component))

	file_server := http.FileServer(http.Dir("./assets"))
	mux.Handle("/assets/", http.StripPrefix("/assets/",
		addGodotHeaders(file_server)))

	mux.HandleFunc("/games/rpg", s.handlerUserStartGame)

	return mux
}

func NewServer(addr string, client *messaging.Client, pub *messaging.Publisher) *Server {
	return &Server{
		Addr:      addr,
		Client:    client,
		Publisher: pub,
	}
}

func (s *Server) ListenAndServe() error {
	srv := &http.Server{
		Addr:    s.Addr,
		Handler: s.RegisterRoutes(),
	}
	return srv.ListenAndServe()
}

--- END OF FILE: ./internal/server/server.go ---

--- START OF FILE: ./cmd/web/main.go ---
package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"
	"net/http"

	"github.com/erlint1212/portfolio/internal/messaging"
	"github.com/erlint1212/portfolio/internal/routing"
	"github.com/erlint1212/portfolio/internal/server"
)

func main() {
	const amqpURL = "amqp://guest:guest@localhost:5672/"
	const port = ":8000"

	client, err := messaging.NewClient(amqpURL)
	if err != nil {
		log.Printf("[WARNING] Could not connect to RabbitMQ: %v. Running in offline mode.", err)
	} else {
		defer client.Close()
	}

	var publisher *messaging.Publisher
	if client != nil {
		publisher, err = messaging.NewPublisher(client.Conn)
		if err != nil {
			log.Printf("[ERROR] Could not create publisher: %v", err)
		} else {
			defer publisher.Close()
		}
	}

	srv := server.NewServer(port, client, publisher)

	if client != nil {
		err := messaging.Subscribe(
			client.Conn,
			routing.ExchangePortfolioTopic,
			routing.GameLogSlug,
			routing.GameLogSlug+".*",
			routing.Durable,
			messaging.HandlerWriteLog(), 
			messaging.UnmarshalGob,
		)
		if err != nil {
			log.Printf("[WARNING] Failed to subscribe to %s: %v\n", routing.GameLogSlug, err)
		}
	}

	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	go func() {
		// 2. Attempt to start the server. This function blocks until the 
    	//    server is turned off.
    	//    Capture any error it returns into the variable 'err'.
		log.Printf("Serving on: http://localhost%s/", srv.Addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			// 3.  check for a specific error: http.ErrServerClosed.
			//    When  eventually call `srv.Shutdown()` (in the main thread), 
			//    `ListenAndServe` will return this specific error.
			//    
			//     WANT that error; it means  shut down successfully.
			//     only want to log a Fatal crash if the error is NOT "ServerClosed"
			//    (e.g., if the port 8000 is already in use by another program).
			log.Fatalf("Listen: %s\n", err)
		}
	}()

	<- stop
	log.Println("\nShutting down server...")

	if client != nil {
		client.Close()
	}
	log.Println("Server exited properly")
}

--- END OF FILE: ./cmd/web/main.go ---
